# bootstrap

[Project description link](https://github.com/ylab-nsu/.github/blob/main/projects/bootstrap.md)

---

## 1) Сформулировать цель и угрозы (1 стр. в README)

- **Цель PoC:** показать атаку «доверяя доверию» (самовоспроизводящийся троян в компиляторе) и затем **обнаружить/нейтрализовать** её с помощью _Diverse Double-Compiling (DDC)_ и _reproducible builds_.
    
- **Угрозы:** заражённый компилятор, зависимость от одной кодовой базы/архитектуры, недетерминизм сборки, неподписанные артефакты.
    
- **Критерий успеха:** (а) троян переживает пересборку из «чистых» исходников; (б) DDC выявляет расхождение побитово; (в) после мер противодействия троян исчезает.

---
## 2) Базовая лаборатория (две независимые сборочные цепочки)

**x86 (возможно «скомпрометированная»):**

- ВМ: Debian/Ubuntu, `gcc`, `clang`, `make`, `qemu-user`, `diffoscope`, `sha256sum`.
    
- Фиксация окружения: Nix/Guix _или_ Docker/Podman, чтобы запуск сборок был воспроизводим.

**RISC-V (как «доверенная» или альтернативная):**

- Устанавливаем QEMU: `sudo apt install qemu-system-misc qemu-user-static`.
    
- Кросс-toolchain: `gcc-riscv64-linux-gnu` _или_ сборка через `crosstool-ng`.
    
- Мини-rootfs (BusyBox + musl) для запуска RISC-V бинарей под эмуляцией.

> [!question] Почему так: нам нужны **две независимые цепочки** (разные компиляторы и/или архитектуры), чтобы провести DDC.

---
## 3) Мини-компилятор для эксперимента (быстро и прозрачно)

Выбери компактный С-компилятор, который легко патчить:

- **tinycc (tcc)** или **lcc** — подходят для демонстрации.
    
- Альтернатива: крошечный учебный компилятор (по книге/курсу), если хочешь «минимальное ядро».

Собери его на x86 и RISC-V:

`# x86 make CC=gcc # RISC-V cross make CC=riscv64-linux-gnu-gcc`

---
## 4) Реализация атаки Томпсона (PoC)

Сделай две модификации в исходниках компилятора **A** (например, tcc):

1. **Триггерная подмена**: если компилятор видит определённый шаблон в «целевой» программе (например, имитация `login.c` или просто `target_app.c`), он генерирует альтернативную ветку (бекдор).
    
2. **Самовоспроизводимость**: добавь во фронтенд распознавание **собственного** шаблона компилятора и генерацию той же вставки («вставляй 1) и 2) в будущие бинарники компилятора»), даже если исходники компилятора «чистые».


Мини-план проверки:

- Скомпилируй заражённый компилятор **A′** исходным «чистым» компилятором **T** → получи бинарь с трояном.
    
- Затем пересобери компилятор из «чистых» исходников **A** с помощью **A′** → получи **A″**, который **снова** содержит троян (хотя в исходниках его нет). Это и есть эффект Томпсона.

---
## 5) Демонстрация DDC (Diverse Double-Compiling)

Идея DDC (Д. Уилер): компилируем один и тот же исходник компилятора двумя _независимыми_ компиляторами/цепочками, затем сравниваем результат.

Пошагово:

1. Собери `A` на x86 **компилятором 1** (скажем, gcc) → `A_gcc`.
    
2. Собери `A` на x86 **компилятором 2** (скажем, clang) **или** кросс-собери на RISC-V, затем перекомпилируй обратно в x86 (через кросс-сборку) → `A_clang` / `A_from_rv`.
    
3. Нормализуй сборку (см. §6) и сравни артефакты:
    

`sha256sum A_gcc A_clang diffoscope A_gcc A_clang`

4. Если троян «самопереносится» только в цепочке с заражением, артефакты **разойдутся**. Это и будет основная демонстрация.

---
## 6) Воспроизводимые сборки (чтобы сравнения были честные)

Сделай сборку детерминированной:

- Экспортируй `SOURCE_DATE_EPOCH=1700000000`.
    
- Убирай нестабильные флаги (`-fno-record-gcc-switches`, выключи встроенные пути времени/пользователя).
    
- Зафиксируй версии зависимостей в `lockfile` (Nix/Guix, `apt snapshot`, Docker digest).
    
- Для архивов/артефактов — `tar --sort=name --owner=0 --group=0 --mtime=@$SOURCE_DATE_EPOCH`.

---
## 7) Контроль целостности и аттестации

- Подписывай артефакты: `cosign sign-blob A_gcc` (sigstore).
    
- Веди «протокол сборки» (_in-toto_ или SLSA provenance) — кто, чем, когда и из каких исходников собрал бинарник.
    
- Храни всё в моно-репо: `/env/` (Nix/Guix/Dockerfiles), `/compiler/` (исходники A), `/targets/` (мишени), `/scripts/` (DDC, сравнение, отчёты), `/attestations/`.

---
## 8) Трасса под RISC-V («доверенный компилятор»)

Мини-дорожка:

1. Разверни `qemu-system-riscv64` с минимальным дистрибутивом (BusyBox).
    
2. Кросс-собери `tcc`/`lcc` под RISC-V, запусти юнит-тесты внутри эмулятора.
    
3. Собери «целевую» программу на RISC-V и проверь, что троян **не** воспроизводится при «чистой» цепочке.
    
4. Используй результат как «вторую независимую цепочку» для DDC на x86 (через перекрёстную сборку компилятора для x86 на RISC-V).

---
## 9) Мини-результаты, которые стоит получить и положить в отчёт

- Скринкаст/лог: заражённый компилятор пересобирает сам себя → троян сохраняется.
    
- Лог DDC: побитовое сравнение двух цепочек → «неравно», diffoscope показывает внедрённые куски.
    
- После включения мер (DDC + reproducible builds + независимый тулчейн) — «равно».
    
- Артефакты и подписи в `releases/` (хеши, cosign, provenance JSON).

---

- Ken Thompson, **Reflections on Trusting Trust** — сама идея атаки.
- David A. Wheeler, **Diverse Double-Compiling (DDC)** — метод обнаружения.
- **reproducible-builds.org** — практики детерминизации.
- **Bootstrappable Builds** (stage0, MesCC, TinyCC) — как выстраивать «доверенную» цепочку с минимального зерна.
- **in-toto, Sigstore, SLSA** — аттестации/подписи.

>[!note] To Read (useful materials)
